<<../EDU-1S-C-project-myshell/src/exec.c>>
//
// Created by XuZY on 2023/11/25.
//
#include "../include/exec.h"
#include "../include/main.h"
#include "../include/prepro_input.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
int exec_cmd(char * cmd[]){
	int status;
	pid_t pid;
	pid = fork();
	if(pid == -1) getError("fork");
	else if(pid == 0){
		// child
		if (execvp(cmd[0],cmd) == ERR ) getError("exec");
	} else{
		globalPID = pid;
		waitpid(pid,&status,0);
		globalPID = 0;
		return WEXITSTATUS(status);
	}
//	getError("exec");
	return -1;
}
int command_cd(char *path){
	if (path == NULL){
		path = getenv("HOME");
	}
	if (chdir(path) != 0) getError("chdir");
	return 1;
}
void exec_pipe(char *cmd){
	int pipefd[2];
	pid_t pid;
	char *cmd_part;
	int fd_in = 0;
	while ((cmd_part = strtok_r(NULL, "|", &cmd))) {
		pipe(pipefd);
		if ((pid = fork()) == -1) {
			perror("fork");
			exit(EXIT_FAILURE);
		}
		if (pid == 0) {
			dup2(fd_in, 0); // 复制 fd_in 到 stdin
			if (*cmd != '\0') {
				dup2(pipefd[1], 1); // 复制 stdout 到 pipefd[1]
			}
			close(pipefd[0]);
			char *args[SIZE];
			split_space(cmd_part, args); // 分割命令行参数
			if (execvp(args[0], args) == -1) {
				perror("execvp");
				exit(EXIT_FAILURE);
			}
		} else {
			wait(NULL); // 等待子进程结束
			close(pipefd[1]);
			fd_in = pipefd[0]; // 将 pipefd[0] 保存为下一个命令的 stdin
		}
	}
}



<<../EDU-1S-C-project-myshell/src/prepro_input.c>>
//
// Created by XuZY on 2023/11/25.
//
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "../include/prepro_input.h"
#include "../include/main.h"
#include "../include/exec.h"
#include "../include/myls.h"
#include "../include/myps.h"
/**
void split_logop(char *input){
	char *rest_line = input;
	char *cmd_seg;
	int last_status = 0;
	int exec_status = 1;
	while ((cmd_seg = strtok_r(rest_line,"&&",&rest_line))){
		char *tabcmd[SIZE];
		split_space(rest_line,tabcmd);
		if ((strstr(cmd_seg,"&&") != NULL && last_status == 0) ||
				(strstr(cmd_seg,"||") != NULL && last_status != 0) ||
				(strstr(cmd_seg,"&&") != NULL && strstr(cmd_seg,"||") == NULL )){
			if (strcmp(tabcmd[0],"cd") == 0){
				last_status = change_dict(tabcmd[1]);
				continue;
			} else if(strcmp(tabcmd[0],"exit")){
				exit(EXIT_SUCCESS);
			}else{
				last_status = exec_cmd(tabcmd);
				exec_status = 1;
			}
		} else{
			exec_status = 0;
		}
	}
}
 **/
//void preprocess(char *input, int length) {
//	if (length > 0 && input[length - 1] == '\n') {
//		input[length - 1] = '\0';
//	}
//	char *rest_line = input;
//	char *cmd_seg;
//	while ((cmd_seg = strtok_r(rest_line, ";", &rest_line))) {
//		char *tabcmd[SIZE], *token, *rest_cmd = cmd_seg;
//		int i = 0;
//
//		while ((token = strtok_r(rest_cmd, " ", &rest_cmd)) != NULL && i < SIZE) {
//			tabcmd[i++] = token;
//		}
//		tabcmd[i] = NULL;
//		if (tabcmd[0] != NULL) {
//			if (strcmp(tabcmd[0], "cd") == 0) {
//				command_cd(tabcmd[1]);
//				continue;
//			} else if (strcmp(tabcmd[0], "myps") == 0) {
//				command_myps();
//				continue;
//			} else if (strcmp(tabcmd[0], "myls") == 0) {
//				command_myls(tabcmd, i);
//				continue;
//			} else if (strcmp(tabcmd[0], "exit") == 0) {
//				exit(EXIT_SUCCESS);
//			} else {
//				exec_cmd(tabcmd);
//			}
//		}
//	}
//
//}
//void preprocess(char *input,int length){
//	if(length > 0 && input[length -1] == '\n'){
//		input[length - 1] = '\0';
//	}
//	char *rest_input = input;
//	char *command_segment;
//	while ((command_segment = strtok_r(rest_input,";",&rest_input))){
//		char *rest_cmd = command_segment;
//		char *cmd_part ;
//		int last_status = 0;
//		int execute_next = 1;
//		char *next = strstr(rest_cmd, "&&");
//		char *next_or = strstr(rest_cmd,"||");
//		char *op = "&&";
//		if (next == NULL || (next_or != NULL && next_or < next)) {
//			op = "||";
//		} // 显示最靠前的逻辑符号
//		while ((cmd_part = strtok_r(rest_cmd,op,&rest_cmd))){
//			char *tabcmd[SIZE],*token,*rrcmd = cmd_part;
//			int i = 0;
//
//			while ((token = strtok_r(rrcmd," ",&rrcmd)) != NULL && i < SIZE){
//				tabcmd[i++] = token;
//			}
//			tabcmd[i] = NULL;
//			if (execute_next){
//				if (strcmp(tabcmd[0],"cd") == 0){
//					command_cd(tabcmd[1]);
//					last_status = 0;
//				} else if(strcmp(tabcmd[0],"exit") == 0){
//					exit(EXIT_SUCCESS);
//				} else if (strcmp(tabcmd[0],"myls") == 0){
//					command_myls(tabcmd,i);
//					last_status = 0;
//					continue;
//				}else{
//					exec_cmd(tabcmd);
//				}
//			}
//			if (*rest_cmd == '&'){
//				execute_next = (last_status == 0);
//			}else if (*rest_cmd == '|'){
//				execute_next = (last_status != 0);
//			}
//
//			if(*rest_cmd != '\0'){
//				rest_cmd++;
//			}
//
//		}
//	}
//}
void preprocess(char *input, int length) {
	if (length > 0 && input[length - 1] == '\n') {
		input[length - 1] = '\0';
	}
	int last_command_status = 0;
	char *rest_input = input;
	char *command_segment;
	while ((command_segment = strtok_r(rest_input, ";", &rest_input))) {
		char *rest_cmd = command_segment;
		int last_status = 0;
		int execute_next = 1;
		if (rest_cmd == NULL){
			break;
		}
		while (*rest_cmd != NULL && *rest_cmd != '\0' ) {
			char *next = strstr(rest_cmd, "&&");
			char *next_or = strstr(rest_cmd, "||");
			char *op_end;
			if (next == NULL || (next_or != NULL && next_or < next)) {
				next = next_or;
				op_end = next ? next + 2 : NULL; // 对于 '||'
			} else {
				op_end = next + 2; // 对于 '&&'
			}
			if (next) {
				*next = '\0'; // 切断当前命令
			}
			if (strstr(rest_cmd,"|")){
				if (execute_next){
					exec_pipe(rest_cmd);
				}
			}else {
				char *tabcmd[SIZE], *token;
				int i = 0;
				while ((token = strtok_r(rest_cmd, " ", &rest_cmd)) != NULL && i < SIZE) {
					tabcmd[i++] = token;
				}
				tabcmd[i] = NULL;
				if (execute_next) {
					if (strcmp(tabcmd[0], "cd") == 0) {
						last_status = command_cd(tabcmd[1]);
					} else if (strcmp(tabcmd[0], "exit") == 0) {
						exit(EXIT_SUCCESS);
					} else if (strcmp(tabcmd[0], "myls") == 0) {
						last_status = command_myls(tabcmd, i);
//						continue;
					}else if (strcmp(tabcmd[0],"status") == 0){
						printf("Last command status = %d",last_command_status);
					}else {
						last_status = exec_cmd(tabcmd);
					}
				}
			}
			if (next) {
				execute_next = (last_status == 0 && strcmp(next, "&") == 0) || (last_status != 0 && strcmp(next, "|") == 0);
				rest_cmd = op_end;
			} else {
				break; // 没有更多的逻辑运算符
			}
		}
		last_command_status = last_status;
	}
}
void split_space(char *cmd, char *args[]) {
	int i = 0;
	char *token;
	while ((token = strtok_r(cmd, " ", &cmd)) != NULL && i < SIZE) {
		args[i++] = token;
	}
	args[i] = NULL;
}
void split_semicolon(char *input) {
	char *rest_line = input;
	char *cmd_seg;
	while ((cmd_seg = strtok_r(rest_line, ";", &rest_line))) {
		char *tabcmd[SIZE];
		split_space(cmd_seg, tabcmd);
		if (strcmp(tabcmd[0], "cd") == 0) {
			command_cd(tabcmd[1]);
			continue;
		} else if (strcmp(tabcmd[0], "exit") == 0) {
			exit(EXIT_SUCCESS);
		}
		exec_cmd(tabcmd);
	}
}
void cut_first(char *msg,char *token){
}
void split(char *input, int length) {
	if (length > 0 && input[length - 1] == '\n') {
		input[length - 1] = '\0';
	}
	char *tabcmds[SIZE];
	int cmd_count = 0;
	// int last_status = 0;
	// int execute_next = 1;
	char *token = strtok(input, ";");
	while (token != NULL && cmd_count < SIZE) {
		tabcmds[cmd_count++] = token;
		token = strtok(NULL, ";");
	}
	for (int i = 0; i < cmd_count; ++i) {
		printf("%s\n", tabcmds[i]);
	}
	for (int i = 0; i < cmd_count; ++i) {
		char *rest = tabcmds[i];
		char *next = strstr(rest, "&&");
		char *next_or = strstr(rest,"||");
		if (next == NULL || (next_or != NULL && next_or < next)) {
			next = next_or;
		}
		int pos_rest = strlen(rest);
		int pos_next = strlen(next);
	}
}


<<../EDU-1S-C-project-myshell/src/main.c>>
//
// Created by XuZY on 2023/11/25.
//
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <signal.h>
#include "../include/prepro_input.h"
#include "../include/main.h"
pid_t globalPID = 0;
void signalHandler(int sig){
	if (sig == SIGINT){
		// 检查当前运行进程
		if(globalPID != 0){//当前进程存在
			kill(globalPID,SIGINT);
		}else{
			printf("none\n");
		}
	}
}
int main() {
	char thiscmd[CMDLEN];
	char cwd[SIZE];
	for (;;) {
//		signal(SIGINT,signalHandler);
		if (getcwd(cwd, sizeof(cwd)) == NULL) getError("getcwd");
		printf("%s -> ",cwd);
		if (fgets(thiscmd, CMDLEN - 1, stdin) == NULL) {
			perror("fgets: None input");
			continue;
		}
		size_t len = strlen(thiscmd);
		preprocess(thiscmd, len);
//		split(thiscmd,len);
	}
}



<<../EDU-1S-C-project-myshell/src/myls.c>>
//
// Created by XuZY on 2023/11/25.
//
#include "../include/myls.h"
#include "../include/main.h"
#include <dirent.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <pwd.h>
#include <grp.h>
#include <time.h>
int command_myls(char *path[], int length) {
	int all = 0, Rec = 0, i;
	char *default_path = "./"; // 默认路径
	// 首先处理所有选项
	for (i = 1; i < length; i++) {
		int res = test_search(path[i]);
		if (res == 0) {
			Rec = 1;
		} else if (res == 1) {
			all = 1;
		} else if (res == 2 || res == 3) {
			all = 1;
			Rec = 1;
		}
	}
	printf("rec = %d , all = %d ",Rec,all);
	// 然后处理所有非选项（即路径）
	for (i = 1; i < length; i++) {
		if (test_search(path[i]) == -1) { // 如果不是选项
			default_path = path[i];
			list_files(default_path, all, Rec);
		}
	}
	// 如果没有指定路径，则使用默认路径
	if (length == 1 || (length == 2 && (all == 1 || Rec == 1))) {
		list_files(default_path, all, Rec);
	}
	return 1;
}
void get_stat(char *file_path,int is_all,int rec) {
	int rt_stat;
	struct stat mystat;
	rt_stat = lstat(file_path, &mystat);
	if (rt_stat < 0){
		printf("%s",file_path);
		perror("lstat");
		exit(EXIT_FAILURE);
	}
	char filemod[11];
	mode_t mod = (&mystat)->st_mode;
	if (rec == 1 && S_ISDIR(mod)){
		char newpath[strlen(file_path)+2];
		strcpy(newpath,file_path);
		strcat(newpath,"/");
//		printf("newpath = %s",newpath);
		list_files(newpath,is_all,rec);
	}
	filemod[0] = S_ISDIR(mod) ? 'd':'-';
	filemod[1] = (mod & S_IRUSR) ? 'r' : '-';
	filemod[2] = (mod & S_IWUSR) ? 'w' : '-';
	filemod[3] = (mod & S_IXUSR) ? 'x' : '-';
	filemod[4] = (mod & S_IRGRP) ? 'r' : '-';
	filemod[5] = (mod & S_IWGRP) ? 'w' : '-';
	filemod[6] = (mod & S_IXGRP) ? 'x' : '-';
	filemod[7] = (mod & S_IROTH) ? 'r' : '-';
	filemod[8] = (mod & S_IWOTH) ? 'w' : '-';
	filemod[9] = (mod & S_IXGRP) ? 'x' : '-';
	filemod[10] = '\0';
	printf("%s",filemod);
	struct passwd *pw = getpwuid((&mystat) -> st_uid);
	struct group *gr = getgrgid((&mystat) -> st_gid);
	char datestring[256];
	struct tm *tm;
	tm = localtime(&(&mystat) -> st_mtime);
	strftime(datestring, sizeof(datestring), "%b %d %H:%M", tm);
	char *color = FILE_COLOR;
	if (S_ISDIR(mystat.st_mode)) {
		color = DIRECTORY_COLOR;
	} else if (mystat.st_mode & S_IXUSR) {
		color = EXECUTABLE_COLOR;
	}
	printf(" %lu \t%s \t%s \t%lld \t%s", (unsigned long)(&mystat)->st_nlink, pw->pw_name, gr->gr_name, (long long)(&mystat)->st_size, datestring);
	printf("\t%s%s%s\n", color, file_path, RESET_COLOR);
}
void list_files(char *the_path,int is_all,int Rec) {
	DIR *mydir;
	mydir = opendir(the_path);
	if (mydir == NULL) {
		perror("opendir");
		exit(EXIT_FAILURE);
	}
	struct dirent *files;
	for (;;) {
		files = readdir(mydir);
		if (files == NULL) {
			break;
		}
		// -a 选项
		if (is_all == 0){
			if (strcmp(files->d_name, ".") == 0 || strcmp(files->d_name, "..") == 0 || files->d_name[0] == '.') {
				continue;
			}
		}
		char s[strlen(the_path) + strlen(files->d_name) + 1];
		strcpy(s, the_path);
		strcat(s,files->d_name);
		get_stat(s,is_all,Rec);
	}
	if (closedir(mydir) == -1) {
		perror("closedir");
	}
}
int test_search(char * options){
	char * target[4] = {"-R","-a","-aR","-Ra"};
	int res;
	int num = -1;
	for (int i = 0;i < 4;i++){
		res = strcmp(options,target[i]);
		if (res == 0){
			num = i;
			break;
		}
	}
	return num;
}



<<../EDU-1S-C-project-myshell/src/myps.c>>
//
// Created by XuZY on 2023/12/2.
//
#include "../include/myps.h"
#include "../include/main.h"
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <dirent.h>
#include <string.h>
#include <ctype.h>
void show_status(const char *path){
	FILE *fp = fopen(path,"r");
	if (fp == NULL) getError("fopen NULL");
	char line[SIZE];
	while (fgets(line, sizeof(line),fp) != NULL){
		if (strncmp(line,"Name:",5) == 0 || strncmp(line,"State:",6) == 0){
			printf("%s",line);
		}
	}
	fclose(fp);
}
void command_myps(){
	DIR *dir = opendir("/proc");
	if (dir == NULL) getError("open proc");
	struct dirent *entry;
	while ((entry = readdir(dir)) != NULL){
		if (entry->d_type == DT_DIR && isdigit(entry->d_name[0])){
			char path[SIZE];
			snprintf(path,sizeof(path),"/proc/%s/status",entry->d_name);
			printf("PID : %s\n",entry->d_name);
			printf("\n");
		}
	}
	closedir(dir);
}


<<../EDU-1S-C-project-myshell/include/main.h>>
//
// Created by XuZY on 2023/11/25.
//
#ifndef EDU_1S_C_PROJECT_MYSHELL_SRC_MAIN_H_
#define EDU_1S_C_PROJECT_MYSHELL_SRC_MAIN_H_
#include <unistd.h>
#define getError(x) perror(x),exit(EXIT_FAILURE)
#define ERR -1
#define CMDLEN 4096
#define SIZE 1024
#define ROUGE(m) "\033[01;31m"m"\033[0m"
#define VERT(m) "\033[01;32m"m"\033[0m"
extern pid_t globalPID;
#endif //EDU_1S_C_PROJECT_MYSHELL_SRC_MAIN_H_



<<../EDU-1S-C-project-myshell/include/myps.h>>
//
// Created by XuZY on 2023/12/2.
//
#ifndef EDU_1S_C_PROJECT_MYSHELL_SRC_MYPS_H_
#define EDU_1S_C_PROJECT_MYSHELL_SRC_MYPS_H_
void command_myps();
#endif //EDU_1S_C_PROJECT_MYSHELL_SRC_MYPS_H_



<<../EDU-1S-C-project-myshell/include/myls.h>>
//
// Created by XuZY on 2023/11/25.
//
#ifndef EDU_1S_C_PROJECT_MYSHELL_SRC_MYSH_H_
#define EDU_1S_C_PROJECT_MYSHELL_SRC_MYSH_H_
#define RESET_COLOR "\x1b[0m"
#define DIRECTORY_COLOR "\x1b[34m"
#define FILE_COLOR "\x1b[0m"
#define EXECUTABLE_COLOR "\x1b[32m"
void get_stat(char *file_path,int is_all,int rec);
int command_myls(char *path[],int length);
void list_files(char *the_path,int is_all,int Rec);
int test_search(char * options);
#endif //EDU_1S_C_PROJECT_MYSHELL_SRC_MYSH_H_



<<../EDU-1S-C-project-myshell/include/exec.h>>
//
// Created by XuZY on 2023/11/25.
//
#ifndef EDU_1S_C_PROJECT_MYSHELL_SRC_EXEC_H_
#define EDU_1S_C_PROJECT_MYSHELL_SRC_EXEC_H_
int exec_cmd(char *cmd[]);
int command_cd(char *path);
void exec_pipe(char *cmd);
#endif //EDU_1S_C_PROJECT_MYSHELL_SRC_EXEC_H_



<<../EDU-1S-C-project-myshell/include/prepro_input.h>>
//
// Created by XuZY on 2023/11/25.
//
#ifndef EDU_1S_C_PROJECT_MYSHELL_SRC_PREPRO_INPUT_H_
#define EDU_1S_C_PROJECT_MYSHELL_SRC_PREPRO_INPUT_H_
void preprocess(char *input,int length);
void split_space(char *cmd,char *args[]);
void split_semicolon(char *input);
void split_logop(char *input);
void split(char *input,int length);
#endif //EDU_1S_C_PROJECT_MYSHELL_SRC_PREPRO_INPUT_H_



