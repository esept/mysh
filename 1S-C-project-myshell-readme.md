# EDU-1S-C-project-myshell

# Todo 
该项目是关于实现一个名为 `mysh` 的简易 shell，具备执行程序的功能。以下是针对这个项目的中文版 To-Do 列表和技术应用概览，以及一个详细的实现指南。

### To-Do 列表

1. **程序执行**：实现基本的命令行输入和程序执行功能。
2. **命令序列**：实现命令通过分号 (;) 无条件串联执行，以及通过 `&&` 和 `||` 条件串联执行。
3. **通配符处理**：实现 `*`, `?`, `[ens]` 等通配符的处理。
4. **内部命令实现**：
    - `cd`：更改当前目录。
    - `exit`：退出 shell。
    - `status`：显示最后一个进程的退出状态。
    - `myls`：类似 `ls` 的命令，支持 `-a` 和 `-R` 选项。
    - `myps`：类似 `ps aux`，但彩色显示进程状态。
5. **输入输出重定向**：实现 `|`, `>`, `>>`, `2>`, `2>>`, `<&`, `>>&` 等重定向操作。
6. **前台和后台执行**：允许命令在前台或后台执行，并通过 `&` 符号区分。
7. **任务管理**：实现 `myjobs` 命令来查看后台进程，以及 `myfg` 和 `mybg` 命令来管理前台和后台任务。
8. **变量处理**：处理环境变量和本地变量。

### 技术应用

1. **C 语言编程**：用于整个 shell 的开发。
2. **系统调用**：使用诸如 `fork`, `exec`, `wait` 等系统调用来执行和管理进程。
3. **信号处理**：处理如 `Ctrl-C` 和 `Ctrl-Z` 的信号，以及与进程管理相关的信号。
4. **字符串解析**：解析用户输入，包括通配符、重定向符号和其他命令行参数。
5. **内存管理**：在处理环境变量和本地变量时进行有效的内存管理。
6. **并发控制**：在处理共享内存和多进程管理时应用。

### 实现指南

1. **基础架构**：首先设置一个循环，用于读取和解析用户输入的命令。
2. **命令解析**：解析命令行输入，区分内部命令和外部命令，并处理通配符和重定向。
3. **进程创建和管理**：使用 `fork` 创建子进程执行命令，`exec` 系列函数加载和运行命令，`wait` 或 `waitpid` 管理子进程的执行。
4. **内部命令实现**：如 `cd`, `exit`，它们需要在当前 shell 进程中直接处理。
5. **信号处理**：注册信号处理函数，以优雅地处理如 `Ctrl-C` 的中断信号。
6. **重定向和管道**：实现标准输入输出的重定向和管道连接。
7. **变量管理**：实现环境变量和本地变量的存储、检索和修改。
8. **前后台任务管理**：实现任务切换，包括将任务从前台移到后台，反之亦然。
9. **错误处理**：优雅地处理各种可能的错误情况，如命令解析错误、系统调用失败等。

这个项目需要扎实的 C 语言基础，对操作系统中的进程管理和文件系统有一定的了解，以及熟悉 shell 的工作原理。项目的难度适中，但需要细心处理各种边界情况和异常。

# 1 

是的，整个项目的第一步是读取和解析用户输入的命令。这个步骤是基础但至关重要的，因为它为后续所有功能的实现奠定了基础。以下是这一步骤的详细指南：

### 读取和解析命令的实现步骤

1. **命令行输入**：
    - 设计一个循环，用于不断地从标准输入（通常是键盘）读取命令行输入。
    - 可以使用像 `getline()` 这样的函数来读取整行输入。

2. **初步处理**：
    - 去除命令行输入的前后空白字符。
    - 检查输入是否为空或仅包含空白字符，如果是，则重新等待输入。

3. **分割命令**：
    - 使用空格为分隔符，将输入的命令行拆分成单独的参数。
    - 可以使用 `strtok()` 或类似的字符串处理函数来实现。

4. **解析特殊字符**：
    - 检测并处理通配符（如 `*` 和 `?`）。
    - 解析重定向和管道符号（如 `>`, `|`）。

5. **区分内部和外部命令**：
    - 决定输入的命令是一个内部命令（如 `cd`、`exit`）还是一个需要调用外部程序的外部命令。
    - 对于内部命令，直接在 shell 中处理；对于外部命令，准备使用系统调用（如 `fork()` 和 `exec()`）来执行。

6. **错误检测**：
    - 对用户输入的命令进行合法性检查。
    - 如果发现错误（如未知的命令或无效的参数），则提供错误提示。

### 技术提示

- 在 C 语言中，字符串的处理需要格外注意内存管理和缓冲区溢出的问题。
- 在解析命令时，考虑到命令的多样性和复杂性，建议使用状态机或类似的复杂数据结构来管理不同的解析状态。
- 对于错误处理，建议采取一种用户友好的方式，例如提供有用的错误信息，而不仅仅是打印出错误代码。

这个步骤是建立一个健壮、高效 shell 的基础，因此值得投入足够的时间和精力来确保其健壮性和可扩展性。

---

以下是您的项目文件中 "2.0 Lancement de commandes", "3- Commandes", "4 Les redirections", "5 Premier et arrière plans", "5.1 Commande myjobs", "6 Les variables" 部分的严格按照文件格式的详细翻译：

### 2. 启动命令

- **2.0 功能**：您的程序应能执行从命令提示符（表示当前目录的 ∼ 代表用户的主目录）读取的程序，并在命令执行完成后重新显示命令提示符。
- **2.1 序列化**：命令可以用分号 (`;`) 无条件链接。例如，`∼> ls ; cat /etc/passwd`。命令也可以使用 `&&` 和 `||` 操作符条件性地链接。例如，`∼> gcc -o mysh myshell.c && ./mysh` 和 `∼> test -d .can || mkdir .can`。如果前一个命令成功（或失败），则执行后一个命令。
- **2.2 通配符 (Wildcards)**：您的 shell 命令行应将通配符替换为当前目录中相应的文件或目录名。要处理的通配符包括：`*`（任意字符序列，可能为空），`?`（单个字符），`[ens]`（字符集合 `ens` 中的一个字符）。如果字符集合前有 `^` 符号，则这些字符被排除在匹配之外。

### 3. 命令

- **3.1 更改目录**：您的 shell 需要一个内部命令 `cd` 来在文件系统中导航。如果没有指定目录，该命令将移动到当前用户的主目录。
- **3.2 退出 Shell**：提供了两种退出 shell 的方法：内部命令 `exit` 退出 shell 但不终止后台任务，而 `Ctrl-C` 会要求确认退出并终止所有后台进程。注意，如果在执行前台任务时按下 `Ctrl-C`，它应传递给正在执行的进程，并不视为退出 shell 的请求。
- **3.3 进程返回码**：内部命令 `status` 显示最后一个前台进程的退出码，正常结束为返回码，异常结束（如通过 `Ctrl-C`）则指示异常终止。
- **3.4 列出目录内容**：作为外部程序，实现一个名为 `myls` 的命令，类似于 `ls -l`，接受 `-a` 和 `-R` 两个选项，分别用于显示隐藏文件和递归列出目录。

### 4. 重定向

- **4.1 管道 (Pipes)**：实现命令之间的管道连接，使用 `|` 符号将一个命令的标准输出重定向到另一个命令的标准输入。
- **4.2 文件重定向**：处理常见的文件重定向，包括 `>`、`>>`（标准输出），`2>`、`2>>`（错误输出），`>&` 和 `>>&`（同时重定向标准输出和错误输出），`<`（标准输入）。

### 5. 前台和后台任务

- **5.0 功能**：到目前为止，所有命令都是在前台执行的。您的 shell 应支持后台执行命令（使用 `&`），在命令没有结束时也显示命令提示符。
- **5.1 myjobs 命令**：内部命令 `myjobs` 显示后台任务的列表，包括任务号、进程 ID 和状态（正在执行或已停止）。
- **5.2 前后台切换**：可以使用 `Ctrl-Z`（SIGTSTP 信号）暂停前台任务，`myfg` 和 `mybg` 命令可以将任务在前后台之间切换。

### 6. 变量



- **6.0 功能**：您的 shell 应处理两种类型的变量：本地变量和环境变量。
- **6.1 环境变量**：环境变量存储在共享内存区域中，由 shell 的第一个实例创建并初始化。最后一个 shell 实例应在退出前销毁这个共享区域。
- **6.2 本地变量**：本地变量仅在您的 shell 实例中有效，不同实例可以有同名的不同本地变量。
- **6.3 变量使用**：在命令行中使用 `$` 符号来访问变量。如果本地和环境中都存在同名变量，则使用本地变量。使用 `set` 和 `setenv` 命令分别设置本地和环境变量。使用 `unset` 和 `unsetenv` 删除本地和环境变量。

---

根据您目前的进度，已经实现了基本的命令读取和解析功能，下一步可以实现一些相对简单且快速的功能。考虑到您的项目要求和当前进度，以下是一些建议：

### 1. 内部命令 `cd` （更改目录）

+ 实现 `cd` 命令相对简单，只需调用 `chdir()` 系统调用。
+ 它不涉及复杂的进程管理或文件操作。

### 2. 内部命令 `exit` （退出 Shell）

+ 实现 `exit` 命令也相对简单，只需确保正确地退出您的程序。
+ 这不需要额外的系统调用或复杂的逻辑。

### 3. 简单的环境变量处理

+ 开始处理环境变量也是一个比较直接的任务。
+ 可以通过访问 `envp` 参数（通常在 `main` 函数中提供）来开始此功能的实现。

这些功能比起复杂的管道、重定向或后台任务管理来说，实现起来相对简单且快速。这将帮助您逐步构建更复杂的 shell 功能，同时保持项目的进展。在实现这些基础功能后，您可以逐步迁移到更高级的功能，如命令管道和重定向等。




